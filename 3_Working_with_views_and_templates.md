# Работа с представлениями и шаблонами
***
***
## Представления

**Представление в Django** — это функция или класс, которая обрабатывает запрос и
возвращает ответ в виде HTTP-ответа. Оно определяет, какие данные будут
отображаться на странице и как они будут отображаться.
Представления распологаются в файле **views.py** вашего приложения. Если проект
состоит из нескольких приложений, каждое будет иметь свои “вьюшки” в
собственном каталоге.
***

### Вместо старта

Если в рамках урока вы создаёте новое приложение, выполните команды:
>cd myproject
>python manage.py startapp myapp3
Сразу добавьте приложение в константу со списком приложений

```python
INSTALLED_APPS = [
    'myapp2',
    'myapp3',
]
```
### Представления на основе функций

**Функциональное представление** — это функция Python, которая принимает объект
запроса и возвращает объект ответа. Она может быть определена как обычная
функция или декоратор. 

Пример функционального представления:
```python
from django.http import HttpResponse


def hello(request):
    return HttpResponse("Hello World from function!")
```
В этом примере мы импортируем класс HttpResponse из модуля django.http и
определяем функцию hello, которая принимает объект запроса request и
возвращает объект ответа HttpResponse с текстом "Hello, World!".

### Представления на основе классов

**Классовое представление** – это класс Python, который наследуется от базового
класса **View** и реализует один или несколько методов для обработки запросов.

Пример классового представления:
```python
from django.views import View
from django.http import HttpResponse


class HelloView(View):
    def get(self, request):
        return HttpResponse("Hello World from class!")
```

В этом примере мы импортируем базовый класс **View** из модуля **django.views** и
определяем класс **HelloView**, который наследуется от него. Метод **get()** класса
**HelloView** обрабатывает **GET-запросы** и возвращает объект ответа **HttpResponse** с
текстом "Hello, World!".

В Django существует множество других типов представлений, таких как шаблонные
представления, которые используют шаблоны **HTML** для отображения данных, или
**API-представления**, которые возвращают данные в формате **JSON** или **XML**. Однако
функциональные и классовые представления являются наиболее
распространенными и простыми в использовании.

Далее в рамках лекции будем использовать различные варианты представлений,
чтобы на примерах закрепить навыки по их созданию. В реальных проектах стоит
выбрать единую концепцию для всех представлений вашего проекта.

## Диспетчер URL
**Диспетчер URL** является одним из ключевых компонентов фреймворка Django,
который отвечает за обработку входящих запросов и направление их на
соответствующие обработчики.

Обработка запросов в Django осуществляется следующим образом: когда
пользователь делает запрос к веб-приложению, сервер Django получает этот запрос
и передает его диспетчеру URL. Диспетчер URL анализирует запрос и определяет,
какой обработчик должен быть вызван для его обработки.
***
### Сопоставление представления с маршрутом
Использование представлений осуществляется путем указания их имени в
URL-адресе приложения. Например, для функционального представления **hello()** и
классового представления **HelloView** можно определить **URL-шаблоны** следующим
образом. 

Создаём файл **urls.py** в каталоге приложения и пишем код:
```python
from django.urls import path
from .views import hello, HelloView


urlpatterns = [
    path('hello/', hello, name='hello'),
    path('hello2/', HelloView.as_view(), name='hello2'),
]
```
Здесь мы определяем **URL-шаблоны** для функционального представления **hello()** и
классового представления **HelloView**. В первом случае мы указываем имя функции в
качестве обработчика запроса, во втором – используем метод **as_view()** класса
HelloView для создания объекта-обработчика запроса.

Далее нам надо подключить маршруты приложения к маршрутам проекта.
Открываем **urls.py** в каталоге проекта и вносим в него изменения. Получим
примерно следующий код:
```python
from django.contrib import admin
from django.urls import path, include


urlpatterns = [
    path('admin/', admin.site.urls),
    ...
    path('les3/', include('myapp3.urls')),
]
```
Добавляется маршрут для приложения **myapp3**, который будет обрабатывать
URL-адрес **les3** в качестве префикса. В случае его совпадения передавать
управление в модуль **myapp3.urls**. Маршрут включается с помощью функции **include**,
а дальнейшая обработка адреса происходит в **urls.py** приложения. Его мы создали
парой абзацев выше.

### Передача параметров
**Преобразования пути** — это процесс преобразования URL-адреса запроса в
формат, понятный для Django. Django преобразует пути запроса в параметры,
которые передаются обработчику. Рассмотрим пример кода в файле **myapp3/urls.py**:
```python
from django.urls import path
...
from .views import year_post, MonthPost, post_detail


urlpatterns = [
    ...
    path('posts/<int:year>/', year_post, name='year_post'),
    path('posts/<int:year>/<int:month>/', MonthPost.as_view(), name='month_post'),
    path('posts/<int:year>/<int:month>/<slug:slug>/', post_detail, name='post_detail'),
]
```
В этом примере мы определяем три маршрута для обработки запросов. В первом
маршруте мы используем параметр `<int:year>`, чтобы указать год статьи. Во втором
маршруте мы используем параметры `<int:year>` и `<int:month>`, чтобы указать год и
месяц статьи. В третьем маршруте мы используем параметры `<int:year>`,
`<int:month>` и `<slug:slug`>, чтобы указать год, месяц и уникальный идентификатор
статьи.

Когда пользователь делает запрос к веб-приложению, Django преобразует
URL-адреса запроса в параметры, которые передаются обработчику. Например,
если пользователь запрашивает статью, опубликованную в июне 2022 года с
идентификатором `python`, Django преобразует URL-адрес запроса в следующие
параметры:
```python
{
'year': 2022,
'month': 6,
'slug': 'python',
}
```
Эти параметры затем передаются обработчику **views.post_detail**, который может
использовать их для отображения соответствующей статьи.
Таким образом, диспетчер URL и преобразования пути являются важными
компонентами фреймворка Django, которые позволяют обрабатывать запросы и
направлять их на соответствующие обработчики.

#### Преобразование пути в типы Python
В Django преобразование путей осуществляется с помощью приставок, которые
определяют тип данных, который будет передаваться в качестве параметра в
представление. Для этого мы заключаем параметр в треугольные скобки и
указываем приставку, а далее после двоеточия слитно пишем имя параметра.

● str — приставка для передачи строки любых символов, кроме слэша.
Например, если мы хотим передать в представление информацию о
конкретном посте блога, то мы можем использовать такой путь:
`path('posts/<str:slug>/', post_detail)`. Здесь slug - это строка символов, которая
является уникальным идентификатором поста.

● **int** — приставка для передачи целого числа. Например, если мы хотим
передать в представление информацию о конкретном пользователе по его
идентификатору, то мы можем использовать такой путь:
`path('users/<int:id>/', user_detail)`. Здесь id - это целое число, которое является
уникальным идентификатором пользователя.

● **slug** — приставка для передачи строки, содержащей только буквы, цифры,
дефисы и знаки подчеркивания. Например, если мы хотим передать в
представление информацию о конкретной категории товаров, то мы можем
использовать такой путь:
`path('categories/<slug:slug>/', category_detail)`. Здесь slug - это строка
символов, которая является уникальным идентификатором категории.

● **uuid** — приставка для передачи уникального идентификатора. Например, если
мы хотим передать в представление информацию о конкретном заказе, то мы
можем использовать такой путь:
`path('orders/<uuid:pk>/', order_detail)`. Здесь pk - это уникальный
идентификатор заказа.

● **path** — приставка для передачи строки любых символов, включая слэши.
Например, если мы хотим передать в представление информацию о
конкретном файле на сервере, то мы можем использовать такой путь:
`path('files/<path:url>/', file_detail)`. Здесь url - это строка символов, которая
содержит путь к файлу на сервере.

### Из URL во view
Снова возвращаемся к представлениям. Следующая строка кода из **myapp3/urls.py**
в настоящий момент вызывает ошибки импорта:
```python
from .views import year_post, MonthPost, post_detail
```
Рассмотрим простейшие вьюшки, которые устранят ошибки в нашем приложении.

#### Представление через функцию возвращает HttpResponse
```python
from django.http import HttpResponse


def year_post(request, year):
    text = ""
    ... # формируем статьи за год
    return HttpResponse(f"Posts from {year}<br>{text}")
```
Это представление будет доступно по адресу http://127.0.0.1:8000/les3/posts/2022/
При этом год может быть любым целым числом.

🔥 **Внимание!** Если вы указали другой префикс в корневом urls, ваш адрес
будет отличаться.

#### Представление через класс возвращает HttpResponse
```python
from django.views import View
from django.http import HttpResponse


class MonthPost(View):
    def get(self, request, year, month):
        text = ""
        ... # формируем статьи за год и месяц
        return HttpResponse(f"Posts from {month}/{year}<br>{text}")
```
Вторая вьюшка основана на классе. Работает метод аналогично первой функции. Но
в качестве параметров мы получаем и год и месяц. Например можно перейти по
адресу http://127.0.0.1:8000/les3/posts/2022/6/

#### Представление через функцию возвращает JSON
```python
from django.http import JsonResponse
def post_detail(request, year, month, slug):
    # Формируем статьи за год и месяц по идентификатору. Пока обойдёмся без запросов к базе данных
    post = {
        "year": year,
        "month": month,
        "slug": slug,
        "title": "Кто быстрее создаёт списки в Python, list() или []",
        "content": "В процессе написания очередной программы задумался над тем, какой способ создания списков в Python работает быстрее..."
    }
    return JsonResponse(post, json_dumps_params={'ensure_ascii': False})
```
В отличии от двух первых представлений, третье возвращает JSON объект.
Очевидное изменение — использование JsonResponse вместо привычного
HttpResponse. Менее очевидное - русский текст. А если быть более точным, текст в
кодировке UTF-8, а не в ASCII. Для этого мы передаём дополнительный параметр
json_dumps_params={'ensure_ascii': False}. Если вы работали с модулем json из
стандартной библиотеки Python, параметр ensure_ascii вам знаком. Он
подтверждает, что JSON будет содержать не только 127 символов из кодировки
ASCII.

Проверить работу представления можно по адресу наподобие
http://127.0.0.1:8000/les3/posts/2022/6/python/

## Шаблоны
***
### Каталог шаблона


### Первый шаблон


### Передача контекста в шаблон


### Проверка условия в шаблонах


#### Пробрасываем контекст в if шаблон используя TemplateView


#### Добавление маршрута


### Вывод в цикле


### Наследование шаблонов Django


#### Базовый шаблон проекта


## Объединяем модели, представления, шаблоны и маршруты
***
### Модели


#### Создание моделей


#### Миграции


#### Наполнение фейковыми данными


### Представления


#### Представление автора


#### Представление статьи


### Маршруты


### Шаблоны


#### Базовый шаблон


#### Шаблон с последними статьями автора


#### Шаблон статьи

***
***
## [К оглавлению](README.md)
## [К предыдущей главе 'Работа с моделями'](2_Working_with_models.md)
## [К следующей главе '--------'](-------.md)